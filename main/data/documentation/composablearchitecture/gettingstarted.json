{"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted"},"seeAlsoSections":[{"generated":true,"anchor":"Essentials","title":"Essentials","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestingTCA","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SharingState","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/FAQ"]}],"primaryContentSections":[{"content":[{"anchor":"Adding-the-Composable-Architecture-as-a-dependency","level":2,"text":"Adding the Composable Architecture as a dependency","type":"heading"},{"inlineContent":[{"text":"To use the Composable Architecture in a SwiftPM project, add it to the dependencies of your","type":"text"},{"text":" ","type":"text"},{"text":"Package.swift and specify the ","type":"text"},{"code":"ComposableArchitecture","type":"codeVoice"},{"text":" product in any targets that need access to","type":"text"},{"text":" ","type":"text"},{"text":"the library:","type":"text"}],"type":"paragraph"},{"code":["let package = Package(","  dependencies: [","    .package(","      url: \"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\",","      from: \"1.0.0\"","    ),","  ],","  targets: [","    .target(","      name: \"<target-name>\",","      dependencies: [","        .product(","          name: \"ComposableArchitecture\",","          package: \"swift-composable-architecture\"","        )","      ]","    )","  ]",")"],"syntax":"swift","type":"codeListing"},{"anchor":"Writing-your-first-feature","level":2,"text":"Writing your first feature","type":"heading"},{"style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":"For a step-by-step interactive tutorial, be sure to check out"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/tutorials\/MeetComposableArchitecture"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"aside"},{"inlineContent":[{"text":"To build a feature using the Composable Architecture you define some types and values that model","type":"text"},{"text":" ","type":"text"},{"text":"your domain:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"State","type":"text"}]},{"type":"text","text":": A type that describes the data your feature needs to perform its logic and render its"},{"type":"text","text":" "},{"type":"text","text":"UI."}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Action"}]},{"type":"text","text":": A type that represents all of the actions that can happen in your feature, such as"},{"type":"text","text":" "},{"type":"text","text":"user actions, notifications, event sources and more."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Reducer"}],"type":"strong"},{"type":"text","text":": A function that describes how to evolve the current state of the app to the next"},{"type":"text","text":" "},{"type":"text","text":"state given an action. The reducer is also responsible for returning any effects that should be"},{"type":"text","text":" "},{"type":"text","text":"run, such as API requests, which can be done by returning an "},{"type":"codeVoice","code":"Effect"},{"type":"text","text":" value."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Store","type":"text"}]},{"type":"text","text":": The runtime that actually drives your feature. You send all user actions to the store"},{"type":"text","text":" "},{"type":"text","text":"so that the store can run the reducer and effects, and you can observe state changes in the"},{"type":"text","text":" "},{"type":"text","text":"store so that you can update UI."}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"The benefits of doing this are that you will instantly unlock testability of your feature, and you"},{"type":"text","text":" "},{"type":"text","text":"will be able to break large, complex features into smaller domains that can be glued together."}],"type":"paragraph"},{"inlineContent":[{"text":"As a basic example, consider a UI that shows a number along with “+” and “−” buttons that increment","type":"text"},{"text":" ","type":"text"},{"text":"and decrement the number. To make things interesting, suppose there is also a button that when","type":"text"},{"text":" ","type":"text"},{"text":"tapped makes an API request to fetch a random fact about that number and displays it in the view.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To implement this feature we create a new type that will house the domain and behavior of the"},{"type":"text","text":" "},{"type":"text","text":"feature, and it will be annotated with the "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer()","overridingTitle":"@Reducer","type":"reference","isActive":true,"overridingTitleInlineContent":[{"type":"codeVoice","code":"@Reducer"}]},{"type":"text","text":" macro:"}],"type":"paragraph"},{"code":["import ComposableArchitecture","","@Reducer","struct Feature {","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In here we need to define a type for the feature’s state, which consists of an integer for the","type":"text"},{"text":" ","type":"text"},{"text":"current count, as well as an optional string that represents the fact being presented:","type":"text"}],"type":"paragraph"},{"code":["@Reducer","struct Feature {","  @ObservableState","  struct State: Equatable {","    var count = 0","    var numberFact: String?","  }","}"],"syntax":"swift","type":"codeListing"},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We’ve applied the "},{"code":"@ObservableState","type":"codeVoice"},{"type":"text","text":" macro to "},{"code":"State","type":"codeVoice"},{"type":"text","text":" in order to take advantage of the"},{"type":"text","text":" "},{"type":"text","text":"observation tools in the library."}]}],"type":"aside"},{"inlineContent":[{"type":"text","text":"We also need to define a type for the feature’s actions. There are the obvious actions, such as"},{"type":"text","text":" "},{"type":"text","text":"tapping the decrement button, increment button, or fact button. But there are also some slightly"},{"type":"text","text":" "},{"type":"text","text":"non-obvious ones, such as the action that occurs when we receive a response from the fact API"},{"type":"text","text":" "},{"type":"text","text":"request:"}],"type":"paragraph"},{"code":["@Reducer","struct Feature {","  @ObservableState","  struct State: Equatable { \/* ... *\/ }","  enum Action {","    case decrementButtonTapped","    case incrementButtonTapped","    case numberFactButtonTapped","    case numberFactResponse(String)","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"And then we implement the "},{"type":"codeVoice","code":"body"},{"type":"text","text":" property, which is responsible for composing the actual logic and"},{"type":"text","text":" "},{"type":"text","text":"behavior for the feature. In it we can use the "},{"type":"codeVoice","code":"Reduce"},{"type":"text","text":" reducer to describe how to change the"},{"type":"text","text":" "},{"type":"text","text":"current state to the next state, and what effects need to be executed. Some actions don’t need to"},{"type":"text","text":" "},{"type":"text","text":"execute effects, and they can return "},{"type":"codeVoice","code":".none"},{"type":"text","text":" to represent that:"}],"type":"paragraph"},{"code":["@Reducer","struct Feature {","  @ObservableState","  struct State: Equatable { \/* ... *\/ }","  enum Action { \/* ... *\/ }","","  var body: some Reducer<State, Action> {","    Reduce { state, action in","      switch action {","      case .decrementButtonTapped:","        state.count -= 1","        return .none","","      case .incrementButtonTapped:","        state.count += 1","        return .none","","      case .numberFactButtonTapped:","        return .run { [count = state.count] send in","          let (data, _) = try await URLSession.shared.data(","            from: URL(string: \"http:\/\/numbersapi.com\/\\(count)\/trivia\")!","          )","          await send(","            .numberFactResponse(String(decoding: data, as: UTF8.self))","          )","        }","","      case let .numberFactResponse(fact):","        state.numberFact = fact","        return .none","      }","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"And then finally we define the view that displays the feature. It holds onto a "},{"type":"codeVoice","code":"StoreOf<Feature>"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"so that it can observe all changes to the state and re-render, and we can send all user actions to"},{"type":"text","text":" "},{"type":"text","text":"the store so that state changes:"}],"type":"paragraph"},{"code":["struct FeatureView: View {","  let store: StoreOf<Feature>","","  var body: some View {","    Form {","      Section {","        Text(\"\\(store.count)\")","        Button(\"Decrement\") { store.send(.decrementButtonTapped) }","        Button(\"Increment\") { store.send(.incrementButtonTapped) }","      }","","      Section {","        Button(\"Number fact\") { store.send(.numberFactButtonTapped) }","      }","      ","      if let fact = store.numberFact {","        Text(fact)","      }","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"It is also straightforward to have a UIKit controller driven off of this store. You can observe","type":"text"},{"text":" ","type":"text"},{"text":"state changes in the store in ","type":"text"},{"code":"viewDidLoad","type":"codeVoice"},{"text":", and then populate the UI components with data from","type":"text"},{"text":" ","type":"text"},{"text":"the store. The code is a bit longer than the SwiftUI version, so we have collapsed it here:","type":"text"}],"type":"paragraph"},{"code":["class FeatureViewController: UIViewController {","  let store: StoreOf<Feature>","","  init(store: StoreOf<Feature>) {","    self.store = store","    super.init(nibName: nil, bundle: nil)","  }","","  required init?(coder: NSCoder) {","    fatalError(\"init(coder:) has not been implemented\")","  }","","  override func viewDidLoad() {","    super.viewDidLoad()","","    let countLabel = UILabel()","    let decrementButton = UIButton()","    let incrementButton = UIButton()","    let factLabel = UILabel()","    ","    \/\/ Omitted: Add subviews and set up constraints...","    ","    observe { [weak self] in","      guard let self ","      else { return }","      ","      countLabel.text = \"\\(self.store.count)\"","      factLabel.text = self.store.numberFact","    }","  }","","  @objc private func incrementButtonTapped() {","    self.store.send(.incrementButtonTapped)","  }","  @objc private func decrementButtonTapped() {","    self.store.send(.decrementButtonTapped)","  }","  @objc private func factButtonTapped() {","    self.store.send(.numberFactButtonTapped)","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Once we are ready to display this view, for example in the app’s entry point, we can construct a"},{"type":"text","text":" "},{"type":"text","text":"store. This can be done by specifying the initial state to start the application in, as well as"},{"type":"text","text":" "},{"type":"text","text":"the reducer that will power the application:"}],"type":"paragraph"},{"code":["import ComposableArchitecture","","@main","struct MyApp: App {","  var body: some Scene {","    WindowGroup {","      FeatureView(","        store: Store(initialState: Feature.State()) {","          Feature()","        }","      )","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"And that is enough to get something on the screen to play around with. It’s definitely a few more","type":"text"},{"text":" ","type":"text"},{"text":"steps than if you were to do this in a vanilla SwiftUI way, but there are a few benefits. It gives","type":"text"},{"text":" ","type":"text"},{"text":"us a consistent manner to apply state mutations, instead of scattering logic in some observable","type":"text"},{"text":" ","type":"text"},{"text":"objects and in various action closures of UI components. It also gives us a concise way of","type":"text"},{"text":" ","type":"text"},{"text":"expressing side effects. And we can immediately test this logic, including the effects, without","type":"text"},{"text":" ","type":"text"},{"text":"doing much additional work.","type":"text"}],"type":"paragraph"},{"anchor":"Testing-your-feature","level":2,"text":"Testing your feature","type":"heading"},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"For more in-depth information on testing, see the dedicated "},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestingTCA","isActive":true,"type":"reference"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"article."}]}],"type":"aside"},{"inlineContent":[{"text":"To test use a ","type":"text"},{"type":"codeVoice","code":"TestStore"},{"text":", which can be created with the same information as the ","type":"text"},{"type":"codeVoice","code":"Store"},{"text":", but it","type":"text"},{"text":" ","type":"text"},{"text":"does extra work to allow you to assert how your feature evolves as actions are sent:","type":"text"}],"type":"paragraph"},{"code":["@Test","func basics() async {","  let store = TestStore(initialState: Feature.State()) {","    Feature()","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Once the test store is created we can use it to make an assertion of an entire user flow of steps."},{"type":"text","text":" "},{"type":"text","text":"Each step of the way we need to prove that state changed how we expect. For example, we can"},{"type":"text","text":" "},{"type":"text","text":"simulate the user flow of tapping on the increment and decrement buttons:"}],"type":"paragraph"},{"code":["\/\/ Test that tapping on the increment\/decrement buttons changes the count","await store.send(.incrementButtonTapped) {","  $0.count = 1","}","await store.send(.decrementButtonTapped) {","  $0.count = 0","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Further, if a step causes an effect to be executed, which feeds data back into the store, we must","type":"text"},{"text":" ","type":"text"},{"text":"assert on that. For example, if we simulate the user tapping on the fact button we expect to","type":"text"},{"text":" ","type":"text"},{"text":"receive a fact response back with the fact, which then causes the ","type":"text"},{"type":"codeVoice","code":"numberFact"},{"text":" state to be","type":"text"},{"text":" ","type":"text"},{"text":"populated:","type":"text"}],"type":"paragraph"},{"code":["await store.send(.numberFactButtonTapped)","","await store.receive(\\.numberFactResponse) {","  $0.numberFact = ???","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"However, how do we know what fact is going to be sent back to us?"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Currently our reducer is using an effect that reaches out into the real world to hit an API server,"},{"type":"text","text":" "},{"type":"text","text":"and that means we have no way to control its behavior. We are at the whims of our internet"},{"type":"text","text":" "},{"type":"text","text":"connectivity and the availability of the API server in order to write this test."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It would be better for this dependency to be passed to the reducer so that we can use a live"},{"type":"text","text":" "},{"type":"text","text":"dependency when running the application on a device, but use a mocked dependency for tests. We can"},{"type":"text","text":" "},{"type":"text","text":"do this by adding a property to the "},{"code":"Feature","type":"codeVoice"},{"type":"text","text":" reducer:"}],"type":"paragraph"},{"code":["@Reducer","struct Feature {","  let numberFact: (Int) async throws -> String","  \/\/ ...","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Then we can use it in the ","type":"text"},{"code":"reduce","type":"codeVoice"},{"text":" implementation:","type":"text"}],"type":"paragraph"},{"code":["case .numberFactButtonTapped:","  return .run { [count = state.count] send in ","    let fact = try await self.numberFact(count)","    await send(.numberFactResponse(fact))","  }"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"And in the entry point of the application we can provide a version of the dependency that actually"},{"type":"text","text":" "},{"type":"text","text":"interacts with the real world API server:"}],"type":"paragraph"},{"code":["@main","struct MyApp: App {","  var body: some Scene {","    WindowGroup {","      FeatureView(","        store: Store(initialState: Feature.State()) {","          Feature(","            numberFact: { number in","              let (data, _) = try await URLSession.shared.data(","                from: URL(string: \"http:\/\/numbersapi.com\/\\(number)\")!","              )","              return String(decoding: data, as: UTF8.self)","            }","          )","        }","      )","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"But in tests we can use a mock dependency that immediately returns a deterministic, predictable"},{"type":"text","text":" "},{"type":"text","text":"fact:"}],"type":"paragraph"},{"code":["@Test","func basics() async {","  let store = TestStore(initialState: Feature.State()) {","    Feature(numberFact: { \"\\($0) is a good number Brent\" })","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"With that little bit of upfront work we can finish the test by simulating the user tapping on the","type":"text"},{"text":" ","type":"text"},{"text":"fact button, and then receiving the response from the dependency to present the fact:","type":"text"}],"type":"paragraph"},{"code":["await store.send(.numberFactButtonTapped)","","await store.receive(\\.numberFactResponse) {","  $0.numberFact = \"0 is a good number Brent\"","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"We can also improve the ergonomics of using the ","type":"text"},{"code":"numberFact","type":"codeVoice"},{"text":" dependency in our application. Over","type":"text"},{"text":" ","type":"text"},{"text":"time the application may evolve into many features, and some of those features may also want access","type":"text"},{"text":" ","type":"text"},{"text":"to ","type":"text"},{"code":"numberFact","type":"codeVoice"},{"text":", and explicitly passing it through all layers can get annoying. There is a process","type":"text"},{"text":" ","type":"text"},{"text":"you can follow to “register” dependencies with the library, making them instantly available to any","type":"text"},{"text":" ","type":"text"},{"text":"layer in the application.","type":"text"}],"type":"paragraph"},{"style":"note","name":"Note","content":[{"inlineContent":[{"text":"For more in-depth information on dependency management, see the dedicated","type":"text"},{"text":" ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","type":"reference","isActive":true},{"text":" article.","type":"text"}],"type":"paragraph"}],"type":"aside"},{"inlineContent":[{"type":"text","text":"We can start by wrapping the number fact functionality in a new type:"}],"type":"paragraph"},{"code":["struct NumberFactClient {","  var fetch: (Int) async throws -> String","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"And then registering that type with the dependency management system by conforming the client to","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"DependencyKey","type":"codeVoice"},{"text":" protocol, which requires you to specify the live value to use when running the","type":"text"},{"text":" ","type":"text"},{"text":"application in simulators or devices:","type":"text"}],"type":"paragraph"},{"code":["extension NumberFactClient: DependencyKey {","  static let liveValue = Self(","    fetch: { number in","      let (data, _) = try await URLSession.shared","        .data(from: URL(string: \"http:\/\/numbersapi.com\/\\(number)\")!","      )","      return String(decoding: data, as: UTF8.self)","    }","  )","}","","extension DependencyValues {","  var numberFact: NumberFactClient {","    get { self[NumberFactClient.self] }","    set { self[NumberFactClient.self] = newValue }","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"With that little bit of upfront work done you can instantly start making use of the dependency in"},{"type":"text","text":" "},{"type":"text","text":"any feature by using the "},{"type":"codeVoice","code":"@Dependency"},{"type":"text","text":" property wrapper:"}],"type":"paragraph"},{"code":[" @Reducer"," struct Feature {","-  let numberFact: (Int) async throws -> String","+  @Dependency(\\.numberFact) var numberFact","   ","   …","","-  try await self.numberFact(count)","+  try await self.numberFact.fetch(count)"," }"],"syntax":"diff","type":"codeListing"},{"inlineContent":[{"text":"This code works exactly as it did before, but you no longer have to explicitly pass the dependency","type":"text"},{"text":" ","type":"text"},{"text":"when constructing the feature’s reducer. When running the app in previews, the simulator or on a","type":"text"},{"text":" ","type":"text"},{"text":"device, the live dependency will be provided to the reducer, and in tests the test dependency will","type":"text"},{"text":" ","type":"text"},{"text":"be provided.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This means the entry point to the application no longer needs to construct dependencies:"}],"type":"paragraph"},{"code":["@main","struct MyApp: App {","  var body: some Scene {","    WindowGroup {","      FeatureView(","        store: Store(initialState: Feature.State()) {","          Feature()","        }","      )","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"And the test store can be constructed without specifying any dependencies, but you can still","type":"text"},{"text":" ","type":"text"},{"text":"override any dependency you need to for the purpose of the test:","type":"text"}],"type":"paragraph"},{"code":["let store = TestStore(initialState: Feature.State()) {","  Feature()","} withDependencies: {","  $0.numberFact.fetch = { \"\\($0) is a good number Brent\" }","}","","\/\/ ..."],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"That is the basics of building and testing a feature in the Composable Architecture. There are","type":"text"},{"text":" ","type":"text"},{"inlineContent":[{"text":"a lot","type":"text"}],"type":"emphasis"},{"text":" more things to be explored. Be sure to check out the ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/tutorials\/MeetComposableArchitecture","type":"reference","isActive":true},{"text":"","type":"text"},{"text":" ","type":"text"},{"text":"tutorial, as well as dedicated articles on ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","type":"reference","isActive":true},{"text":", ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestingTCA","type":"reference","isActive":true},{"text":",","type":"text"},{"text":" ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation","type":"reference","isActive":true},{"text":", ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","type":"reference","isActive":true},{"text":", and more. Also, the ","type":"text"},{"identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\/tree\/main\/Examples","type":"reference","isActive":true},{"text":" directory has","type":"text"},{"text":" ","type":"text"},{"text":"a bunch of projects to explore to see more advanced usages.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"sections":[],"abstract":[{"text":"Learn how to integrate the Composable Architecture into your project and write your first","type":"text"},{"text":" ","type":"text"},{"text":"application.","type":"text"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/composablearchitecture\/gettingstarted"]}],"kind":"article","metadata":{"roleHeading":"Article","modules":[{"name":"ComposableArchitecture"}],"role":"article","title":"Getting started"},"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/FAQ":{"role":"article","url":"\/documentation\/composablearchitecture\/faq","title":"Frequently asked questions","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/FAQ","type":"topic","abstract":[{"text":"A collection of some of the most common questions and comments people have concerning the library.","type":"text"}],"kind":"article"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/DependencyManagement":{"url":"\/documentation\/composablearchitecture\/dependencymanagement","abstract":[{"type":"text","text":"Learn how to register dependencies with the library so that they can be immediately accessible from"},{"type":"text","text":" "},{"type":"text","text":"any reducer."}],"kind":"article","type":"topic","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/DependencyManagement","role":"article","title":"Dependencies"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer":{"url":"\/documentation\/composablearchitecture\/reducer","kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Reducer"}],"title":"Reducer","abstract":[{"text":"A protocol that describes how to evolve the current state of an application to the next state,","type":"text"},{"text":" ","type":"text"},{"text":"given an action, and describes what ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Effect","isActive":true,"type":"reference"},{"text":"s should be executed later by the store, if any.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Reducer"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","type":"topic","role":"symbol"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Reducer()":{"kind":"symbol","type":"topic","abstract":[{"text":"Helps implement the conformance to the ","type":"text"},{"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer","isActive":true,"type":"reference"},{"text":" protocol for a type.","type":"text"}],"fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Reducer","kind":"identifier"},{"text":"()","kind":"text"}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Reducer()","title":"Reducer()","role":"symbol","url":"\/documentation\/composablearchitecture\/reducer()"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestingTCA":{"abstract":[{"text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable","type":"text"},{"text":" ","type":"text"},{"text":"Architecture.","type":"text"}],"kind":"article","type":"topic","role":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestingTCA","url":"\/documentation\/composablearchitecture\/testingtca","title":"Testing"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/SharingState":{"kind":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/SharingState","abstract":[{"type":"text","text":"Learn techniques for sharing state throughout many parts of your application, and how to persist"},{"type":"text","text":" "},{"type":"text","text":"data to user defaults, the file system, and other external mediums."}],"url":"\/documentation\/composablearchitecture\/sharingstate","title":"Sharing state","type":"topic","role":"article"},"doc://ComposableArchitecture/tutorials/MeetComposableArchitecture":{"kind":"overview","title":"Meet the Composable Architecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a"},{"type":"text","text":" "},{"type":"text","text":"consistent and understandable way, with composition, testing, and ergonomics in mind. It can be"},{"type":"text","text":" "},{"type":"text","text":"used in SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"role":"overview","type":"topic","identifier":"doc:\/\/ComposableArchitecture\/tutorials\/MeetComposableArchitecture","url":"\/tutorials\/meetcomposablearchitecture"},"https://github.com/pointfreeco/swift-composable-architecture/tree/main/Examples":{"titleInlineContent":[{"text":"Examples","type":"text"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\/tree\/main\/Examples","title":"Examples","url":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture\/tree\/main\/Examples"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Navigation":{"url":"\/documentation\/composablearchitecture\/navigation","abstract":[{"text":"Learn how to use the navigation tools in the library, including how to best model your domains, how","type":"text"},{"text":" ","type":"text"},{"text":"to integrate features in the reducer and view layers, and how to write tests.","type":"text"}],"role":"collectionGroup","type":"topic","title":"Navigation","kind":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Navigation"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Performance":{"role":"article","type":"topic","abstract":[{"text":"Learn how to improve the performance of features built in the Composable Architecture.","type":"text"}],"title":"Performance","kind":"article","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","url":"\/documentation\/composablearchitecture\/performance"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"url":"\/documentation\/composablearchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"title":"ComposableArchitecture","role":"collection","kind":"symbol","type":"topic","identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"}}}